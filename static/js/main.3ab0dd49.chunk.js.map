{"version":3,"sources":["ramka.png","App.js","serviceWorker.js","index.js"],"names":["module","exports","App","fileReader","useState","fileContent","setFileContent","Date","date","setDate","number","setNumber","scale","setScale","x","setX","y","setY","bytes","setBytes","pdfBytes","setpdfBytes","ramkaBytes","setRamkaBytes","useEffect","prepareRamka","handleFileRead","e","content","result","console","log","a","fetch","ramka","then","res","arrayBuffer","pngImageBytes","PDFDocument","create","imgpdf","embedPng","pngImage","addPage","width","height","pngDims","embedFont","StandardFonts","HelveticaBold","helveticaFont","pages","getPages","firstPage","drawImage","drawText","toLocaleDateString","size","font","color","rgb","save","ramkaBlob","Blob","type","ramkaBlobUrl","URL","createObjectURL","modifyPdf","load","pdfDocContent","pdfDoc","copyPages","ramkapage","contentPage","embedPage","embeddedPageRamka","embeddedPageContent","embeddedPageRamkaDims","embeddedPageContentDims","page","drawPage","getWidth","getHeight","blob","blobUrl","moment","format","className","onClick","reportName","byte","link","document","createElement","href","window","fileName","download","click","saveByteArray","onChange","event","target","files","FileReader","onloadend","readAsArrayBuffer","accept","defaultValue","Number","value","newDate","handleDateChange","toString","src","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.3ab0dd49.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/ramka.3144896e.png\";","import React, { useState, useEffect } from \"react\";\nimport ramka from \"./ramka.png\";\nimport * as moment from \"moment\";\nimport \"./App.css\";\nimport { PDFDocument, rgb, StandardFonts } from \"pdf-lib\";\n\nfunction App() {\n  const [fileContent, setFileContent] = useState(\"\");\n  const [date, setDate] = useState(new Date());\n  const [number, setNumber] = useState(\"P.1425.2020.\");\n  const [scale, setScale] = useState(0.7);\n\n  const [x, setX] = useState(20);\n  const [y, setY] = useState(20);\n\n  const [bytes, setBytes] = useState(null);\n\n  const [pdfBytes, setpdfBytes] = useState(null);\n\n  const [ramkaBytes, setRamkaBytes] = useState(null);\n\n  useEffect(() => {\n    prepareRamka();\n  }, [number, date]);\n\n  //android_2b3292be1f79c49b karola\n  let fileReader;\n  function saveByteArray(reportName, byte) {\n    var blob = new Blob([byte], { type: \"application/pdf\" });\n    var link = document.createElement(\"a\");\n    link.href = window.URL.createObjectURL(blob);\n    var fileName = reportName;\n    link.download = fileName;\n    link.click();\n  }\n  const handleFileRead = (e) => {\n    const content = fileReader.result;\n    console.log(content);\n    setFileContent(content);\n  };\n\n  const handleChange = (content) => {\n    fileReader = new FileReader();\n    fileReader.onloadend = handleFileRead;\n    fileReader.readAsArrayBuffer(content);\n    console.log(fileReader, fileReader.result, fileContent);\n  };\n\n  const prepareRamka = async () => {\n    //// pdf z tabelki z uzupelnionymi danymi\n    const pngImageBytes = await fetch(ramka).then((res) => res.arrayBuffer());\n\n    const imgpdf = await PDFDocument.create();\n    const pngImage = await imgpdf.embedPng(pngImageBytes);\n    imgpdf.addPage([pngImage.width, pngImage.height]);\n\n    const pngDims = pngImage.scale(1); // wielkosc ramki\n    const helveticaFont = await imgpdf.embedFont(StandardFonts.HelveticaBold);\n\n    const pages = imgpdf.getPages();\n    const firstPage = pages[0];\n\n    firstPage.drawImage(pngImage, {\n      x: 0,\n      y: 0,\n      width: pngDims.width,\n      height: pngDims.height,\n    });\n\n    // data\n    firstPage.drawText(date.toLocaleDateString(), {\n      x: 200,\n      y: 100,\n      size: 10,\n      font: helveticaFont,\n      color: rgb(0.95, 0.1, 0.1),\n    });\n\n    //numerek\n    firstPage.drawText(number, {\n      x: 200,\n      y: 125,\n      size: 12,\n      font: helveticaFont,\n      color: rgb(0.95, 0.1, 0.1),\n    });\n\n    let ramkaBytes = await imgpdf.save();\n\n    const ramkaBlob = new Blob([ramkaBytes], { type: \"application/pdf\" });\n    const ramkaBlobUrl = URL.createObjectURL(ramkaBlob);\n\n    setRamkaBytes(ramkaBlobUrl);\n    return imgpdf;\n  };\n  async function modifyPdf() {\n    let imgpdf = await prepareRamka();\n\n    const pdfDocContent = await PDFDocument.load(fileContent);\n\n    const pdfDoc = await PDFDocument.create();\n\n    let [ramkapage] = await pdfDoc.copyPages(imgpdf, [0]);\n    let [contentPage] = await pdfDoc.copyPages(pdfDocContent, [0]);\n\n    let embeddedPageRamka = await pdfDoc.embedPage(ramkapage);\n    let embeddedPageContent = await pdfDoc.embedPage(contentPage);\n\n    const embeddedPageRamkaDims = embeddedPageRamka.scale(scale);\n    const embeddedPageContentDims = embeddedPageContent.scale(1);\n\n    const page = pdfDoc.addPage();\n    page.drawPage(embeddedPageRamka, {\n      ...embeddedPageRamkaDims,\n      x: page.getWidth() - embeddedPageRamkaDims.width - x,\n      y: page.getHeight() - embeddedPageRamkaDims.height - y,\n    });\n\n    page.drawPage(embeddedPageContent, {\n      ...embeddedPageContentDims,\n      x: page.getWidth() / 2 - embeddedPageContentDims.width / 2,\n      y: page.getHeight() / 2 - embeddedPageContentDims.height / 2 - 50,\n    });\n\n    const pdfBytes = await pdfDoc.save();\n    setBytes(pdfBytes);\n    const blob = new Blob([pdfBytes], { type: \"application/pdf\" });\n    const blobUrl = URL.createObjectURL(blob);\n\n    setpdfBytes(blobUrl);\n  }\n\n  const handleDateChange = (value) => {\n    let newDate = new Date(value);\n    setDate(newDate);\n  };\n  console.log(\"asdasdadsd\", moment(date).format(\"DD.MM.YYYY\"));\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <button type=\"submit\" onClick={async () => await modifyPdf()}>\n          RUN\n        </button>\n\n        <button type=\"submit\" onClick={() => saveByteArray(\"pdf\", bytes)}>\n          download\n        </button>\n\n        <div className=\"row\">\n          <div className=\"column\">\n            <div>\n              <label>plik pdf: </label>\n              <input\n                type=\"file\"\n                onChange={(event) => handleChange(event.target.files[0])}\n                accept=\".pdf\"\n              ></input>\n            </div>\n\n            <div>\n              <label>skala czerownej ramki: </label>\n              <input\n                type=\"number\"\n                defaultValue={scale}\n                onChange={(event) => setScale(Number(event.target.value))}\n              />\n            </div>\n            <div>\n              <label>x: </label>\n              <input\n                type=\"number\"\n                defaultValue={x}\n                onChange={(event) => setX(Number(event.target.value))}\n              />\n            </div>\n            <div>\n              <label>y: </label>\n              <input\n                type=\"number\"\n                defaultValue={y}\n                onChange={(event) => setY(Number(event.target.value))}\n              />\n            </div>\n          </div>\n          <div className=\"column\">\n            <div>\n              <label>numer roboty: </label>\n              <input\n                type=\"text\"\n                defaultValue={number}\n                onChange={(event) => setNumber(event.target.value)}\n              />\n            </div>\n\n            <div>\n              <label>data: </label>\n              <input\n                type=\"date\"\n                defaultValue={moment(date).format(\"YYYY-MM-DD\")}\n                onChange={(event) => {\n                  handleDateChange(event.target.value.toString());\n                }}\n              />\n            </div>\n\n          </div>\n        </div>\n\n        <div className=\"row\">\n          <div className=\"column-input\">\n          <iframe onClick={(e) => console.log(e)} src={pdfBytes}></iframe>\n          </div>\n          <div className=\"column-input\">\n          <iframe src={ramkaBytes}></iframe>\n          </div>\n        </div>\n      </header>\n    </div>\n  );\n}\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}